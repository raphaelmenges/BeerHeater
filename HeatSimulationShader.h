#ifndef HEATSIMULATIONSHADER_H_
#define HEATSIMULATIONSHADER_H_

const char* heatSimComputeShader =
"#version 430 core\n"
"struct Mat{\n"
"   vec4 color;\n"
"   vec4 cisf;\n"
"   vec4 dppp;\n"
"};\n"
"layout(local_size_x=4, local_size_y=4, local_size_z=4) in;\n"
"layout(rgba32f, location = 0) uniform image3D stateVolume;\n"
"layout(r32f, location = 1) uniform image3D lookupVolume;\n"
"layout(std430, binding=0) buffer Material\n"
"{\n"
"   Mat m[];\n"
"};\n"
"uniform float timeStep;\n"
"uniform float edgeLength;\n"
"uniform int relaxationSteps;\n"
"float getTemperature(ivec3 coords){\n"
"   return imageLoad(stateVolume, coords).x;\n"
"}\n"
"void main()\n"
"{\n"
//  Hacking values...
"   float weight = 10000;\n"
//  Initialize values
"   ivec3 coords = ivec3(gl_GlobalInvocationID);\n"
"   float area = 0.5 / edgeLength*edgeLength;\n" // TODO
"   float invTimeStep = 1.0 / timeStep;\n" // Quite high, fasten things up
"   vec4 myState = imageLoad(stateVolume, coords);"
"   vec4 oldState = myState;\n"
//  Neighors
"   ivec3 left = ivec3(coords.x+1, coords.y, coords.z);\n"
"   ivec3 right = ivec3(coords.x-1, coords.y, coords.z);\n"
"   ivec3 top = ivec3(coords.x, coords.y+1, coords.z);\n"
"   ivec3 down = ivec3(coords.x, coords.y-1, coords.z);\n"
"   ivec3 front = ivec3(coords.x, coords.y, coords.z+1);\n"
"   ivec3 back = ivec3(coords.x, coords.y, coords.z-1);\n"
//  Pepare neighbor stuff
"   int myLookup = int(imageLoad(lookupVolume, coords).x);\n"
"   int leftLookup = int(imageLoad(lookupVolume, left).x);\n"
"   int rightLookup = int(imageLoad(lookupVolume, right).x);\n"
"   int topLookup = int(imageLoad(lookupVolume, top).x);\n"
"   int downLookup = int(imageLoad(lookupVolume, down).x);\n"
"   int frontookup = int(imageLoad(lookupVolume, front).x);\n"
"   int backLookup = int(imageLoad(lookupVolume, back).x);\n"
//  Prepare values for relaxations
"   float sij = m[myLookup].cisf.z * m[myLookup].dppp.x * invTimeStep;\n"
"   float rij = m[myLookup].cisf.x;\n"
"   float axij = weight * area * (rij + m[leftLookup].cisf.x);\n"
"   float bxij = weight * area * (rij + m[rightLookup].cisf.x);\n"
"   float ayij = weight * area * (rij + m[topLookup].cisf.x);\n"
"   float byij = weight * area * (rij + m[downLookup].cisf.x);\n"
"   float azij = weight * area * (rij + m[frontookup].cisf.x);\n"
"   float bzij = weight * area * (rij + m[backLookup].cisf.x);\n"
"   float normalization = 1.0 / (sij + axij + bxij + ayij + byij + azij + bzij);\n"
//  Do relaxation
"   for(int i = 0; i < relaxationSteps; i++)\n"
"   {\n"
"       myState.x "
"       = oldState.x * sij"
"       + axij * getTemperature(left)"
"       + bxij * getTemperature(right)"
"       + ayij * getTemperature(top)"
"       + byij * getTemperature(down)"
"       + azij * getTemperature(front)"
"       + bzij * getTemperature(back);"
"       myState.x *= normalization;\n"
"       imageStore(stateVolume, coords, myState);\n"
"       barrier();"
"   }\n"
//  Heater
"   float internalHeat = m[myLookup].cisf.y;"
"   if(internalHeat > 0)\n"
"   {\n"
"       myState.x = internalHeat;\n"
"       imageStore(stateVolume, coords, myState);\n"
"   }\n"
"   barrier();"
//  Convection (DOES NOT WORK AT THE MOMENT)
"   float t = 0.5f * timeStep / edgeLength;\n" // 0.5 correct
"   float temperature;\n"
"   if(m[myLookup].cisf.w > 0.f)\n"
"   {\n"
"       vec4 stateLeft = imageLoad(stateVolume, left);\n"
"       vec4 stateRight = imageLoad(stateVolume, right);\n"
"       vec4 stateTop = imageLoad(stateVolume, top);\n"
"       vec4 stateDown = imageLoad(stateVolume, down);\n"
"       vec4 stateFront = imageLoad(stateVolume, front);\n"
"       vec4 stateBack = imageLoad(stateVolume, back);\n"
"       temperature"
"       = myState.x"
"       - t * (stateLeft.y * stateLeft.x - stateRight.y * stateRight.x)\n"
"       - t * (stateTop.z * stateTop.x - stateDown.z * stateDown.x)\n"
"       - t * (stateFront.w * stateFront.x - stateBack.w * stateFront.x);\n"
"       imageStore(stateVolume, coords, myState);\n"
"   }\n"
"   barrier();\n" // Has to be outside of if
//  Save some values
"   float tempSaveLeft = getTemperature(left);\n"
"   float tempSaveRight = getTemperature(right);\n"
"   float tempSaveTop = getTemperature(top);\n"
"   float tempSaveDown = getTemperature(down);\n"
"   float tempSaveFront = getTemperature(front);\n"
"   float tempSaveBack = getTemperature(back);\n"
"   barrier();\n"
"   if(m[myLookup].cisf.w > 0.f)\n"
"   {\n"
"       myState.x"
"       = 0.5 * (myState.x + temperature)"
"       - 0.5 * t * myState.y * (tempSaveLeft - tempSaveRight)"
"       - 0.5 * t * myState.z * (tempSaveTop - tempSaveDown)"
"       - 0.5 * t * myState.w * (tempSaveFront - tempSaveBack);\n"
"       imageStore(stateVolume, coords, myState);\n"
"   }\n"
"}\n";

#endif // HEATSIMULATIONSHADER_H_
